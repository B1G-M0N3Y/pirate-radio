# Phase 0: Backend Set Up

First, you need to setup the backend of your application. This includes
installing dependencies, setting up Sequelize, initializing your Express
application, connecting Express security middlewares, and testing your server
setup.

## Backend and Frontend Separation

In this project, you will separate the backend Express code from the frontend
React code.

Create a folder called `authenticate-me`. Inside that folder, create two more
folders called `backend` and `frontend`.

Your file structure should look like this:

```plaintext
authenticate-me
├── backend
└── frontend
```

## `.gitignore`

Create a `.gitignore` file at the root of the project with the following
contents:

```plaintext
node_modules
.env
build
.DS_Store
*.db
```

## Git

Initiate Git in the project folder by running the following command in the
`authenticate-me` folder:

```bash
git init
```

[Create a public remote git repository in GitHub][new-git-repo] called
"API project" for now. (You can rename of this repository later once you know
what the name of your website will be).

**Note**: Make sure the GitHub repo that you create is "Public", NOT "Private".

Connect your remote repository to your local repository by running the following
command in the `authenticate-me` folder:

```bash
git remote add origin <github-remote-url>
```

Replace `github-remote-url` with the URL that was generated by
GitHub after creating the public remote GitHub repository.

Make your first commit and push it to the remote repository.

```bash
git add .
git status
```

Confirm that the files to be added include the `.gitignore` file that you
created.

Commit the changes:

```bash
git commit -m 'Initial commit'
```

Push the commit to the GitHub remote repository:

```bash
git push origin main
```

Confirm that you see the `.gitignore` file on GitHub.

## Dependencies

`cd` into the `backend` folder and initialize the server's `package.json` by
running `npm init -y`.

`npm install` the following packages as dependencies:

- `cookie-parser` - parsing cookies from requests
- `cors` - CORS
- `csurf` - CSRF protection
- `dotenv` - load environment variables into Node.js from a `.env` file
- `express` - Express
- `express-async-errors` - handling `async` route handlers
- `helmet` - security middleware
- `jsonwebtoken` - JWT
- `morgan` - logging information about server requests/responses
- `per-env` - use environment variables for starting app differently
- `sequelize@6` - Sequelize
- `sequelize-cli@6` - use `sequelize` in the command line

`npm install -D` the following packages as dev-dependencies:

- `sqlite3` - SQLite3
- `dotenv-cli` - use `dotenv` in the command line
- `nodemon` - hot reload server `backend` files

## Configuration

In the `backend` folder, create a `.env` file that will be used to define your
environment variables.

Populate the `.env` file based on the example below:

```plaintext
PORT=8000
DB_FILE=db/dev.db
JWT_SECRET=«generate_strong_secret_here»
JWT_EXPIRES_IN=604800
```

Assign `PORT` to `8000`, and a strong JWT secret.

> Recommendation to generate a strong secret: create a random string using
> `openssl` (a library that should already be installed in your Ubuntu/MacOS
> shell). Run `openssl rand -base64 10` to generate a random JWT secret.

Next, you will create a `js` configuration file that will read the environment
variables loaded and export them.

Add a folder called `config` in your `backend` folder. Inside of the folder,
create an `index.js` file with the following contents:

```js
// backend/config/index.js
module.exports = {
  environment: process.env.NODE_ENV || 'development',
  port: process.env.PORT || 8000,
  dbFile: process.env.DB_FILE,
  jwtConfig: {
    secret: process.env.JWT_SECRET,
    expiresIn: process.env.JWT_EXPIRES_IN
  }
};
```

Each environment variable will be read and exported as a key from this file.

## Sequelize Setup

You will set up Sequelize to look in the `backend/config/database.js` file for
its database configurations. You will also set up the `backend/db` folder to
contain all the files for models, seeders, and migrations.

To do this, create a `.sequelizerc` file in the `backend` folder with the
following contents:

```js
// backend/.sequelizerc
const path = require('path');

module.exports = {
  config: path.resolve('config', 'database.js'),
  'models-path': path.resolve('db', 'models'),
  'seeders-path': path.resolve('db', 'seeders'),
  'migrations-path': path.resolve('db', 'migrations')
};
```

Initialize Sequelize to the `db` folder by running:

```bash
npx sequelize init
```

Replace the contents of the newly created `backend/config/database.js` file with
the following:

```js
// backend/config/database.js
const config = require('./index');

module.exports = {
  development: {
    storage: config.dbFile,
    dialect: "sqlite",
    seederStorage: "sequelize",
    logQueryParameters: true,
    typeValidation: true
  },
  production: {
    use_env_variable: 'DATABASE_URL',
    dialect: 'postgres',
    seederStorage: 'sequelize',
    dialectOptions: {
      ssl: {
        require: true,
        rejectUnauthorized: false
      }
    }
  }
};
```

This will allow you to load the database configuration environment variables
from the `.env` file into the `config/index.js`.

Notice how the `production` database configuration has different keys than the
`development` configuration? When you deploy your application to production,
your database will be read from a URL path instead of a local database file. You
will also be using PostgresQL in production rather than SQLite3 as a SQL
database management system. Recall that SQLite3 is supposed to be used
**ONLY in development**. PostgresQL is a production-level database management
system.

Finally, migrate the database using `sequelize-cli` to make sure you set
everything up correctly.

```bash
npx dotenv sequelize db:migrate
```

Remember, any `sequelize db:` commands need to be prefixed with `dotenv` to load
the database configuration environment variables from the `.env` file.

## Express Setup

After you setup Sequelize, it's time to start working on getting your Express
application set up.

### `app.js`

Create a file called `app.js` in the `backend` folder. Here you will initialize
your Express application.

At the top of the file, import the following packages:

```js
const express = require('express');
require('express-async-errors');
const morgan = require('morgan');
const cors = require('cors');
const csurf = require('csurf');
const helmet = require('helmet');
const cookieParser = require('cookie-parser');
```

Create a variable called `isProduction` that will be `true` if the environment
is in production or not by checking the `environment` key in the configuration
file (`backend/config/index.js`):

```js
const { environment } = require('./config');
const isProduction = environment === 'production';
```

Initialize the Express application:

```js
const app = express();
```

Connect the `morgan` middleware for logging information about requests and
responses:

```js
app.use(morgan('dev'));
```

Add the `cookie-parser` middleware for parsing cookies and the `express.json`
middleware for parsing JSON bodies of requests with `Content-Type` of
`"application/json"`.

```js
app.use(cookieParser());
app.use(express.json());
```

Add several security middlewares:

1. Only allow CORS (Cross-Origin Resource Sharing) in development using the
`cors` middleware because the React frontend will be served from a different
server than the Express server. CORS isn't needed in production since all of our
React and Express resources will come from the same origin.
2. Enable better overall security with the `helmet` middleware (for more on what
`helmet` is doing, see [helmet on the `npm` registry]). React is generally safe
at mitigating XSS (i.e., [Cross-Site Scripting]) attacks, but do be sure to
research how to protect your users from such attacks in React when deploying a
large production application. Now add the `crossOriginResourcePolicy` to the
`helmet` middleware with a `policy` of `cross-origin`. This will allow images
with URLs to render in deployment.
3. Add the `csurf` middleware and configure it to use cookies.

```js
// Security Middleware
if (!isProduction) {
  // enable cors only in development
  app.use(cors());
}

// helmet helps set a variety of headers to better secure your app
app.use(
  helmet.crossOriginResourcePolicy({ 
    policy: "cross-origin" 
  })
);

// Set the _csrf token and create req.csrfToken method
app.use(
  csurf({
    cookie: {
      secure: isProduction,
      sameSite: isProduction && "Lax",
      httpOnly: true
    }
  })
);
```

The `csurf` middleware will add a `_csrf` cookie that is HTTP-only (can't be
read by JavaScript) to any server response. It also adds a method on all
requests (`req.csrfToken`) that will be set to another cookie (`XSRF-TOKEN`)
later on. These two cookies work together to provide CSRF (Cross-Site Request
Forgery) protection for your application. The `XSRF-TOKEN` cookie value needs to
be sent in the header of any request with all HTTP verbs besides `GET`. This
header will be used to validate the `_csrf` cookie to confirm that the
request comes from your site and not an unauthorized site.

Now that you set up all the pre-request middleware, it's time to set up the
routes for your Express application.

### Routes

Create a folder called `routes` in your `backend` folder. All your routes will
live in this folder.

Create an `index.js` file in the `routes` folder. In this file, create an
Express router, create a test route, and export the router at the bottom of the
file.

```js
// backend/routes/index.js
const express = require('express');
const router = express.Router();

router.get('/hello/world', function(req, res) {
  res.cookie('XSRF-TOKEN', req.csrfToken());
  res.send('Hello World!');
});

module.exports = router;
```

In this test route, you are setting a cookie on the response with the name of
`XSRF-TOKEN` to the value of the `req.csrfToken` method's return. Then, you are
sending the text, `Hello World!` as the response's body.

Add the routes to the Express application by importing with the other imports
in `backend/app.js` and connecting the exported router to `app` after all the
middlewares.

```js
// backend/app.js
const routes = require('./routes');

// ...

app.use(routes); // Connect all the routes
```

Finally, at the bottom of the `app.js` file, export `app`.

```js
// backend/app.js
// ...

module.exports = app;
```

After setting up the Express application, it's time to create the server.

### `bin/www`

Conventionally, the `bin/www` file in an Express server is the entry file or the
starting point to start the Express server.

The intention of the `./bin/www` file is for it to be an executable
script, meaning that you could start the application by simply entering the file
name in the terminal as a command:

```sh
bin/www
```

Create a folder in `backend` called `bin`. Inside of it, add a file called
`www` with the following contents:

```js
#!/usr/bin/env node
// backend/bin/www

// Import environment variables
require('dotenv').config();

const { port } = require('../config');

const app = require('../app');
const db = require('../db/models');

// Check the database connection before starting the app
db.sequelize
  .authenticate()
  .then(() => {
    console.log('Database connection success! Sequelize is ready to use...');

    // Start listening for connections
    app.listen(port, () => console.log(`Listening on port ${port}...`));
  })
  .catch((err) => {
    console.log('Database connection failure.');
    console.error(err);
  });
```

Here, you will be starting your Express application to listen for server
requests only after authenticating your database connection.

## Test the Server

At this point, your database, Express application, and server are all set up and
ready to be tested!

In your `package.json`, add the following scripts:

```json
  "scripts": {
    "sequelize": "sequelize",
    "sequelize-cli": "sequelize-cli",
    "start": "per-env",
    "start:development": "nodemon ./bin/www",
    "start:production": "node ./bin/www"
  }
```

`npm start` will run the `/bin/www` in `nodemon` when started in the development
environment with the environment variables in the `.env` file loaded, or in
`node` when started in production.

Now, it's time to finally test your entire set up!

Run `npm start` in the `backend` folder to start your server on the port defined
in the `.env` file, which should be `8000`.

Navigate to the test route at [http://localhost:8000/hello/world]. You should
see the text `Hello World!`. Take a look at your cookies in the `Application`
tab of your Chrome DevTools Inspector. Delete all the cookies to make sure there
are no lingering cookies from other projects, then refresh the page. You should
still see the text `Hello World!` on the page as well as two cookies, one called
`_csrf` and the other called `XSRF-TOKEN` in your DevTools.

If you don't see this, then check your backend server logs in the terminal
where you ran `npm start`. Then check your routes.

If there is a database connection error, make sure you set up the correct
username and password defined in the `.env` file.

When you're finished testing, commit! Now is a good time to commit because you
have working code.

## CSRF Token access for development

You can now remove the `GET /hello/world` test route.

Add a route, `GET /api/csrf/restore` to allow any developer to re-set the CSRF
token cookie `XSRF-TOKEN`.

In this route, you are setting a cookie on the response with the
name of `XSRF-TOKEN` to the value of the `req.csrfToken` method's return. Then,
send the token as the response for easy retrieval.

Add this route to the `backend/routes/index.js` file.

```js
// backend/routes/index.js
// ...
// Add a XSRF-TOKEN cookie
router.get("/api/csrf/restore", (req, res) => {
  const csrfToken = req.csrfToken();
  res.cookie("XSRF-TOKEN", csrfToken);
  res.status(200).json({
    'XSRF-Token': csrfToken
  });
});
// ...
```

This route should not be available in production, but it will not be exclusive
to the production application until you implement the frontend of the
application later. So for now, it will remain available to both the development
and production environments.

## Commit your code

Now is a good time to commit and push your code to GitHub!

Here's a recommendation for what to write as your commit message:
"Initialize Express and Sequelize with CSRF protection"

[new-git-repo]: https://github.com/new
[helmet on the `npm` registry]: https://www.npmjs.com/package/helmet
[Express error-handling middleware]: https://expressjs.com/en/guide/using-middleware.html#middleware.error-handling
[model-level validations]: https://sequelize.org/master/manual/validations-and-constraints.html
[model scoping]: https://sequelize.org/master/manual/scopes.html
[Content Security Policy]: https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP
[Cross-Site Scripting]: https://developer.mozilla.org/en-US/docs/Glossary/Cross-site_scripting
[crossOriginResourcePolicy]: https://www.npmjs.com/package/helmet
[http://localhost:8000/hello/world]: http://localhost:8000/hello/world
[http://localhost:8000/not-found]: http://localhost:8000/not-found
[http://localhost:8000/api/set-token-cookie]: http://localhost:8000/api/set-token-cookie
[http://localhost:8000/api/restore-user]: http://localhost:8000/api/restore-user
[http://localhost:8000/api/require-auth]: http://localhost:8000/api/require-auth
[http://localhost:8000/api/session]: http://localhost:8000/api/session
[http://localhost:8000/api/csrf/restore]: http://localhost:8000/api/csrf/restore